// Generated by CoffeeScript 1.4.0
var Hawk;

Hawk = (function() {

  Hawk.algorithms = ['sha1', 'sha256'];

  Hawk.headerVersion = '1';

  function Hawk() {}

  Hawk.header = function(uri, method, options) {
    var artifacts, credentials, header, mac, result, timestamp;
    result = {
      field: '',
      artifacts: {}
    };
    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') || !method || typeof method !== 'string' || !options || typeof options !== 'object') {
      return result;
    }
    credentials = options.credentials;
    if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
      return result;
    } else if (this.algorithms.indexOf(credentials.algorithm) === -1) {
      return result;
    }
    timestamp = options.timestamp || Math.floor((Date.now() + (options.localtimeOffsetMsec || 0)) / 1000);
    console.log(parseUri(uri));
    console.log(urlParse(uri));
    if (typeof uri === 'string') {
      uri = parseUri(uri);
    }
    artifacts = {
      credentials: credentials,
      ts: timestamp,
      nonce: options.nonce || this.randomString(6),
      method: method,
      resource: uri.relative,
      host: uri.host,
      port: uri.port || (uri.protocol === 'http' ? 80 : 443),
      hash: options.hash,
      ext: options.ext,
      app: options.app,
      dlg: options.dlg
    };
    result.artifacts = artifacts;
    if (!artifacts.hash && (options.payload != null)) {
      artifacts.hash = this.calculateHash(options.payload, credentials.algorithm, options.contentType);
    }
    mac = this.calculateMac('header', artifacts);
    header = "Hawk id=\"" + credentials.id + "\", ts=\"" + artifacts.ts + "\", nonce=\"" + artifacts.nonce + "\"";
    if (artifacts.hash) {
      header += ", hash=\"" + artifacts.hash + "\"";
    }
    if ((artifacts.ext != null) && artifacts.ext !== '') {
      header += ", ext=\"" + (this.escapeHeaderAttribute(artifacts.ext)) + "\"";
    }
    header += ", mac=\"" + mac + "\"";
    if (artifacts.app) {
      if (artifacts.dlg) {
        header += ", dlg=\"" + artifacts.dlg + "\"";
      }
      header += ", app=\"" + artifacts.app + "\"";
    }
    result.field = header;
    return result;
  };

  Hawk.authenticate = function(res, artifacts, options) {
    var attributes, calculatedHash, mac, tsm;
    artifacts = this.cloneObject(artifacts);
    options = options || {};
    if (res.headers['www-authenticate']) {
      attributes = this.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
      if (!attributes) {
        return false;
      }
      if (attributes.ts) {
        tsm = this.calculateTsMac(attributes.ts, artifacts.credentials);
        if (!this.fixedTimeComparison(tsm, attributes.tsm)) {
          return false;
        }
      }
    }
    if (!res.headers['server-authorization'] && !options.required) {
      return true;
    }
    attributes = this.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (!attributes) {
      return false;
    }
    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;
    mac = this.calculateMac('response', artifacts);
    if (!this.fixedTimeComparison(mac, attributes.mac)) {
      return false;
    }
    if (!options.hasOwnProperty('payload')) {
      return true;
    }
    calculatedHash = this.calculateHash(options.payload, artifacts.credentials.algorithm, res.headers['content-type']);
    return this.fixedTimeComparison(calculatedHash, attributes.hash);
  };

  Hawk.calculateMac = function(type, options) {
    var hash, hmac, normalized;
    normalized = this.generateNormalizedString(type, options);
    hmac = this.createHmac(options.credentials.algorithm, options.credentials.key);
    hmac = hmac.update(normalized);
    hash = hmac.finalize();
    return hash.toString(CryptoJS.enc.Base64);
  };

  Hawk.createHmac = function(algo, key) {
    if (algo === 'sha256') {
      return CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
    } else {
      return CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA1, key);
    }
  };

  Hawk.generateNormalizedString = function(type, options) {
    var normalized;
    normalized = 'hawk.' + this.headerVersion + '.' + type + '\n' + options.ts + '\n' + options.nonce + '\n' + options.method.toUpperCase() + '\n' + options.resource + '\n' + options.host.toLowerCase() + '\n' + options.port + '\n' + (options.hash || '') + '\n';
    if (options.ext) {
      normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }
    normalized += '\n';
    if (options.app) {
      normalized += options.app + '\n' + (options.dlg || '') + '\n';
    }
    return normalized;
  };

  Hawk.calculateHash = function(payload, algorithm, contentType) {
    var hash;
    hash = this.createHash(algorithm);
    hash.update('hawk.' + this.headerVersion + '.payload\n');
    hash.update(this.parseContentType(contentType) + '\n');
    hash.update(payload || '');
    hash.update('\n');
    hash = hash.finalize();
    return hash.toString(CryptoJS.enc.Base64);
  };

  Hawk.createHash = function(algo) {
    if (algo === 'sha256') {
      return CryptoJS.algo.SHA256.create();
    } else {
      return CryptoJS.algo.SHA1.create();
    }
  };

  Hawk.calculateTsMac = function(ts, credentials) {
    var hash;
    hash = this.createHash(credentials.algorithm);
    hash.update('hawk.' + this.headerVersion + '.ts\n' + ts + '\n');
    hash = hash.finalize();
    return hash.toString(CryptoJS.enc.Base64);
  };

  Hawk.parseContentType = function(header) {
    if (!header) {
      return '';
    }
    return header.split(';')[0].trim().toLowerCase();
  };

  Hawk.parseAuthorizationHeader = function(header, keys) {
    var attributes, attributesString, headerParts, scheme, verify;
    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];
    if (!header) {
      return false;
    }
    headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);
    if (!headerParts) {
      return false;
    }
    scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') {
      return false;
    }
    attributesString = headerParts[2];
    if (!attributesString) {
      return false;
    }
    attributes = {};
    verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function($0, $1, $2) {
      if (keys.indexOf($1) === -1 || $2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null || attributes.hasOwnProperty($1)) {

      } else {
        attributes[$1] = $2;
        return '';
      }
    });
    if (verify !== '') {
      return false;
    } else {
      return attributes;
    }
  };

  Hawk.cloneObject = function(obj) {
    var flags, i, newObj;
    if (obj === null || obj === void 0) {
      return null;
    }
    if (typeof obj !== 'object') {
      return obj;
    }
    newObj = obj instanceof Array ? [] : {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (obj[i] instanceof Date) {
          newObj[i] = new Date(obj[i].getTime());
        } else if (obj[i] instanceof RegExp) {
          flags = '';
          if (obj[i].global) {
            flags += 'g';
          }
          if (obj[i].ignoreCase) {
            flags += 'i';
          }
          if (obj[i].multiline) {
            flags += 'm';
          }
          if (obj[i].sticky) {
            flags += 'y';
          }
          newObj[i] = new RegExp(obj[i].source, flags);
        } else {
          newObj[i] = this.cloneObject(obj[i]);
        }
      }
    }
    return newObj;
  };

  Hawk.randomString = function(size) {
    var buffer, string;
    buffer = CryptoJS.lib.WordArray.random(Math.ceil(((size + 1) * 6) / 8));
    buffer = buffer.toString(CryptoJS.enc.Base64);
    string = buffer.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
  };

  Hawk.fixedTimeComparison = function(a, b) {
    var ac, bc, i, mismatch, _i, _ref;
    mismatch = (a.length === b.length ? 0 : 1);
    if (mismatch) {
      b = a;
    }
    for (i = _i = 0, _ref = a.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      ac = a.charCodeAt(i);
      bc = b.charCodeAt(i);
      mismatch += (ac === bc ? 0 : 1);
    }
    return mismatch === 0;
  };

  Hawk.escapeHeaderAttribute = function(attribute) {
    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
  };

  return Hawk;

})();
